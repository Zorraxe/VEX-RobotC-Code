#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl2,  clawPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           DriveL2,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           ArmR1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ArmR2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           DriveR1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           DriveL1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ArmR3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ArmL3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ArmL2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ArmL1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          DriveR2,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

int autoNumber = 0;
int last_nLCDButtons_Value = 0;

int LPower;
int RPower;
int armPower;
int clawPower;

int armHold;
int armPos;
int desArmPos;

//int clawHold;
//int clawPos;
int desClawPos;
int last_Btn6U_Value;
int ClawState;

int minTurnPower = 30;
int minMovePower = 60;

int bottomLimit = 0;
int topLimit = 2500;
int motorCap(int value)
{
	if (value > 127)
		return 127;
	else if (value < -127)
		return -127;
	else
		return value;
}

const unsigned int TrueSpeedArray[128] =
{
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 0, 0, 0, 0, 22, 22, 23, 24, 24,
	25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
	28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90,127,127,127
};


#include "2YSSWV_AutoFunc.c"
#include "2YSSWV_Auto.c"

string msgTable[] =	 // Autonomous names
{
	"CubeR ",
	"CubeL ",
	"StarL ",
	"StarR",
};

//LCD-----------------------------------------------------------------------------------------------------------------------
task LCDControl()
{

	while(true)
	{

		int curr_nLCDButtons_Value = nLCDButtons;

		if(nLCDButtons == 4 && curr_nLCDButtons_Value != last_nLCDButtons_Value) // Decrease autoNumber
		{
			if (autoNumber < 3) autoNumber++;
		}
		else if(nLCDButtons == 1 && curr_nLCDButtons_Value != last_nLCDButtons_Value) // Increase autoNumber
		{
			if (autoNumber > 0) autoNumber--;
		}
		clearLCDLine(0);
		displayLCDPos(0,0);
		displayNextLCDString("Battery:");
		displayLCDPos(0 ,9);
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(0,14);
		displayNextLCDString("mV");
		clearLCDLine(1);
		displayLCDPos(1,0);
		displayNextLCDString(msgTable[autoNumber]); // Show current autonomous name in line 2
		bLCDBacklight = true;
		wait1Msec(100);
		last_nLCDButtons_Value = curr_nLCDButtons_Value;

	}
}
//-------------------------------------------------------------------------------------------------------------------------------
void pre_auton()
{
	gyroInitialize ();
	bStopTasksBetweenModes = true;
	startTask (LCDControl);

}

task motorControl ()
{
	while (1)
	{
		armPos = SensorValue[armPot];
		SensorValue[clawPiston] = ClawState;

		motor[DriveL1] = motor[DriveL2] = LPower;
		motor[DriveR1] = motor[DriveR2] = RPower;

		motor[ArmL1] = motor[ArmL2] = motor[ArmL3] = motor[ArmR1] = motor[ArmR2] = motor[ArmR3] = armPower;
	}
}

task armTask()
{
	while (1)
	{
		if (armHold)
		{
			int error = armPos - desArmPos;

			armPower = motorCap(error*0.15);
		}
	}
}

//-------------------------------------------------------------------------------------------------------
task autonomous()
{
	startTask(motorControl);
	startTask(armTask);
	startTask (LCDControl);
	switch(autoNumber) // Start autonomous based on autoNumber variable
	{
	case 0: CubeR();
		break;
	case 1: CubeL();
		break;
	case 2: StarL();
		break;
	case 3: StarR();
		break;
	}
}

task usercontrol()
{
	startTask(motorControl);
	//startTask(clawTask);
	startTask(armTask);
	int clamp = 0;
	startTask(LCDControl);
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ARM~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	while (true)
	{
		if ((vexRT[Btn5U]) && (SensorValue[armPot] < topLimit))
		{
			armPower = -127;
			armHold = 0;
		}
		else if ((vexRT[Btn5D]) && (SensorValue[armPot] > bottomLimit))
		{
			armPower = 127;
			armHold = 0;
		}
		else
		{
			if (!armHold)
			{
				armPower = 0;
				wait10Msec(10);
				desArmPos = SensorValue[armPot];
				armHold = 1;
			}
		}

		if (vexRT[Btn7D])
		{
			desArmPos = bottomLimit + 25;
		}

		if (vexRT[Btn6D])
		{
			desArmPos = bottomLimit + 750;
		}

		if (vexRT[Btn7U])
		{
			clamp = 0;
			desArmPos = bottomLimit + 1200;
			desClawPos = 1720;
		}



		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~DRIVE~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


		if (abs(vexRT[Ch3]) > 20)
		{
			LPower = vexRT[Ch3] > 0 ? TrueSpeedArray[abs(vexRT[Ch3])] : -TrueSpeedArray[abs(vexRT[Ch3])];
		}
		else
		{
			LPower = 0;
		}

		if (abs(vexRT[Ch2]) > 20)
		{
			RPower = vexRT[Ch2] > 0 ? TrueSpeedArray[abs(vexRT[Ch2])] : -TrueSpeedArray[abs(vexRT[Ch2])];
		}
		else
		{
			RPower = 0;
		}


		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~CLAW~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


		int curr_Btn6U_Value = vexRT[Btn6U];
		if (vexRT[Btn6U] ==1 && curr_Btn6U_Value != last_Btn6U_Value && ClawState == 0)
		{
			ClawState = 1;
		}
		else if (vexRT[Btn6U] ==1 && curr_Btn6U_Value != last_Btn6U_Value && ClawState == 1)
		{
			ClawState = 0;
		}
		last_Btn6U_Value = curr_Btn6U_Value;

		//string mainBattery, backupBattery;

		//{
		//	clearLCDLine(0);
		//	clearLCDLine(1);

		//	displayLCDString(0, 0, "Primary: ");
		//	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		//	displayNextLCDString(mainBattery);

		//	wait1Msec(100);
		//}


		//if (vexRT[Btn6U])
		//{
		//	clawPower = 127;
		//	clawHold = 0;
		//	clamp = 1;
		//}
		//else if (vexRT[Btn6D])
		//{
		//	clawPower = -127;
		//	clawHold = 0;
		//	clamp = 0;
		//}
		//else
		//{
		//	if (!clamp)
		//	{
		//		if (!clawHold)
		//		{
		//			clawPower = 0;
		//			wait10Msec(10);
		//			desClawPos = SensorValue[clawPot];
		//			clawHold = 1;
		//		}
		//	}
		//	else if (clamp)
		//	{
		//		if (clawPos > 380)
		//		{
		//			clawPower = 15;
		//		}
		//		else
		//		{
		//			clawPower = 0;
		//			wait10Msec(10);
		//			desClawPos = SensorValue[clawPot];
		//			clawHold = 1;
		//		}
		//	}
		//}

 }
}
